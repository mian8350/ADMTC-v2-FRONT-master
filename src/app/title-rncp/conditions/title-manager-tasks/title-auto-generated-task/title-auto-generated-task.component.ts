import { ParseLocalToUtcPipe } from 'app/shared/pipes/parse-local-to-utc.pipe';
import { ParseUtcToLocalPipe } from './../../../../shared/pipes/parse-utc-to-local.pipe';
import { UserService } from './../../../../service/user/user.service';
import { SubSink } from 'subsink';
import { Router, ActivatedRoute } from '@angular/router';
import { TranslateService, LangChangeEvent } from '@ngx-translate/core';
import { startWith, map, filter, debounceTime, tap } from 'rxjs/operators';
import { Observable } from 'rxjs';
import { cloneDeep, find } from 'lodash';
import { RNCPTitlesService } from 'app/service/rncpTitles/rncp-titles.service';
import { UntypedFormControl } from '@angular/forms';
import { MatDialog } from '@angular/material/dialog';
import { MatPaginator } from '@angular/material/paginator';
import { Sort, MatSort } from '@angular/material/sort';
import { MatTableDataSource } from '@angular/material/table';
import { Component, Input, OnInit, ViewChild, OnDestroy, AfterViewInit, Output, EventEmitter } from '@angular/core';
import * as moment from 'moment';
import Swal from 'sweetalert2';
import { TaskManagerSetupDialogComponent } from './task-manager-setup-dialog/task-manager-setup-dialog.component';
import { TaskService } from 'app/service/task/task.service';
import { ClassTaskStatus } from '../title-manager-tasks.component';
import { SelectionModel } from '@angular/cdk/collections';
@Component({
  selector: 'ms-title-auto-generated-task',
  templateUrl: './title-auto-generated-task.component.html',
  styleUrls: ['./title-auto-generated-task.component.scss'],
  providers: [ParseUtcToLocalPipe, ParseLocalToUtcPipe],
})
export class TitleAutoGeneratedTaskComponent implements OnInit, AfterViewInit, OnDestroy {
  _classTaskStatus: any;
  @Input() rncpId: string;
  @Input() classId: string;
  taskIds: any[];
  dataChecked: any;
  @Input() set classTaskStatus(value: ClassTaskStatus) {
    if (value) {
      this._classTaskStatus = value;
      if (value.is_task_builder_selected) {
        this.getData();
        this.getUserType();
        this.initFilter();
      } else {
        this.openSetupDialog(value);
      }
    }
  }

  get classTaskStatus() {
    return this._classTaskStatus;
  }

  @Output() onGenerateAllTask: EventEmitter<boolean> = new EventEmitter(false);
  dataSource = new MatTableDataSource([]);
  displayedColumns: string[] = ['select', 'taskRef', 'scopeTask', 'taskTitle', 'assigner', 'assignTo', 'dueDate', 'status', 'action'];
  filterColumns: string[] = [
    'selectFilter',
    'taskRefFilter',
    'scopeTaskFilter',
    'taskTitleFilter',
    'assignerFilter',
    'assignToFilter',
    'dueDateFilter',
    'statusFilter',
    'actionFilter',
  ];
  taskRefFilter = new UntypedFormControl('');
  scopeTaskFilter = new UntypedFormControl('');
  taskTitleFilter = new UntypedFormControl('');
  assignerFilter = new UntypedFormControl('');
  assignToFilter = new UntypedFormControl('');
  dueDateFilter = new UntypedFormControl('');
  statusFilter = new UntypedFormControl('');
  isWaitingForResponse = false;
  isLoading = false;
  userType = [];
  assignerListFilter: Observable<any[]>;
  assignerList = [];
  assignerToListFilter: Observable<any[]>;
  assignerToList = [];
  sortValue = null;
  dataCount = 0;
  @ViewChild(MatPaginator, { static: true }) paginator: MatPaginator;
  @ViewChild(MatSort, { static: true }) sort: MatSort;
  private subs = new SubSink();
  filteredValues = {
    ref_id: null,
    task_scope: null,
    task_title: null,
    assigner_id: null,
    assign_to_id: null,
    due_date: null,
    is_published: null,
  };
  rncpTitleId;
  titleTask = [];
  isReset = false;
  statusDropdown = [
    { value: '', name: 'All' },
    { value: true, name: 'Generated' },
    { value: false, name: 'Not Generated' },
  ];
  schoolDropdown = [];
  timeOutVal;
  isAllChecked: boolean = false;
  selection = new SelectionModel<any>(true, []);

  constructor(
    private rncpTitleService: RNCPTitlesService,
    private user: UserService,
    private translate: TranslateService,
    private router: Router,
    private route: ActivatedRoute,
    private parseUTCtoLocal: ParseUtcToLocalPipe,
    private parseLocaltoUTC: ParseLocalToUtcPipe,
    private taskService: TaskService,
    public dialog: MatDialog,
  ) {}

  ngOnInit() {
    const params = this.route.snapshot.params;
    this.rncpTitleId = params && params.rncpId ? params.rncpId : '';
  }

  ngAfterViewInit() {
    this.subs.sink = this.paginator.page
      .pipe(
        startWith(null),
        tap(() => {

          if (!this.isReset) {
            this.getData();
          }
        }),
      )
      .subscribe();
  }

  openSetupDialog(classData) {
    this.subs.sink = this.dialog
      .open(TaskManagerSetupDialogComponent, {
        minWidth: '420px',
        panelClass: 'no-padding-dialog',
        disableClose: true,
        data: {
          originClassId: classData._id,
          originTitleId: classData.parent_rncp_title._id,
        },
      })
      .afterClosed()
      .subscribe((result) => {
        setTimeout(() => this.getData(), 3000);
      });
  }

  getData() {
    this.isWaitingForResponse = true;
    let pagination;
    if (this.isAllChecked) {
      pagination = null;
    } else {
      pagination = {
        limit: this.paginator.pageSize ? this.paginator.pageSize : 10,
        page: this.paginator.pageIndex ? this.paginator.pageIndex : 0,
      };
    }

    this.filteredValues['offset'] = moment().utcOffset();
    if (this.classId && this.rncpTitleId) {
      this.filteredValues['class_id'] = this.classId;
      this.filteredValues['rncp_title_id'] = this.rncpTitleId;
    } else {
      // Prevent query to be called when class id and rncp title id does not exist yet(async)
      return;
    }
    if (!this.filteredValues['class_id'] || !this.filteredValues['rncp_title_id']) return;
    this.subs.sink = this.rncpTitleService.getAllTaskBuilder(pagination, this.sortValue, this.filteredValues).subscribe(
      (resp) => {
        if (resp) {
          if (this.isAllChecked) {
            this.dataChecked = cloneDeep(resp);
            this.taskIds = this.dataChecked.map((el) => el._id);

          } else {

            const tempResp = cloneDeep(resp);
            tempResp.forEach((element) => {
              if (element.assign_to_id && element.assign_to_id.name) {
                element.assign_to_id.name === 'ADMTC Director' ? (element.assign_to_id.name = 'Title Manager') : element.assign_to_id.name;
              }
              if (element.assigner_id && element.assigner_id.name) {
                element.assigner_id.name === 'ADMTC Director' ? (element.assigner_id.name = 'Title Manager') : element.assigner_id.name;
              }
            });
            this.dataSource.data = cloneDeep(tempResp);
            this.titleTask = cloneDeep(resp);
            this.paginator.length = resp && resp.length && resp[0].count_document ? resp[0].count_document : 0;
            this.dataCount = resp && resp.length && resp[0].count_document ? resp[0].count_document : 0;
          }
        } else {
          this.titleTask = [];
          this.dataSource.data = [];
          this.paginator.length = 0;
        }
        this.isReset = false;
        this.isWaitingForResponse = false;
      },
      (err) => {
        this.isWaitingForResponse = false;
        this.isReset = false;
        this.titleTask = [];
        this.dataSource.data = [];
        this.paginator.length = 0;

      },
    );
  }
  sortTable(sort: Sort) {

    if (sort.active === 'taskRef') {
      this.sortValue = sort.direction ? { ref_id: sort.direction } : null;
    } else if (sort.active === 'scopeTask') {
      this.sortValue = sort.direction ? { task_scope: sort.direction } : null;
    } else if (sort.active === 'taskTitle') {
      this.sortValue = sort.direction ? { task_title: sort.direction } : null;
    } else if (sort.active === 'assigner') {
      this.sortValue = sort.direction ? { assigner_id: sort.direction } : null;
    } else if (sort.active === 'assignTo') {
      this.sortValue = sort.direction ? { assign_to_id: sort.direction } : null;
    } else if (sort.active === 'dueDate') {
      this.sortValue = sort.direction ? { due_date: sort.direction } : null;
    } else if (sort.active === 'status') {
      this.sortValue = sort.direction ? { is_published: sort.direction } : null;
    }
    this.paginator.pageIndex = 0;
    if (!this.isReset) {
      this.getData();
    }
  }
  initFilter() {
    this.subs.sink = this.taskRefFilter.valueChanges.pipe(debounceTime(500)).subscribe((value) => {
      this.filteredValues.ref_id = value;
      this.paginator.pageIndex = 0;
      if (!this.isReset) {
        this.getData();
      }
    });
    this.subs.sink = this.taskTitleFilter.valueChanges.pipe(debounceTime(500)).subscribe((value) => {
      this.filteredValues.task_title = value;
      this.paginator.pageIndex = 0;
      if (!this.isReset) {
        this.getData();
      }
    });
    this.subs.sink = this.scopeTaskFilter.valueChanges.subscribe((value) => {
      this.filteredValues.task_scope = value ? value : null;
      this.paginator.pageIndex = 0;
      if (!this.isReset) {
        this.getData();
      }
    });
    this.subs.sink = this.assignerFilter.valueChanges.subscribe((value) => {
      this.filteredValues.assigner_id = value ? value : null;
      this.paginator.pageIndex = 0;
      if (!this.isReset) {
        this.getData();
      }
    });
    this.subs.sink = this.assignToFilter.valueChanges.subscribe((value) => {
      this.filteredValues.assign_to_id = value ? value : null;
      this.paginator.pageIndex = 0;
      if (!this.isReset) {
        this.getData();
      }
    });
    this.subs.sink = this.dueDateFilter.valueChanges.subscribe((value) => {
      let date;
      if (value) {
        date = moment(value).format('DD/MM/YYYY');
      }
      this.filteredValues.due_date = value ? date : null;
      this.paginator.pageIndex = 0;
      if (!this.isReset) {
        this.getData();
      }
    });
    this.subs.sink = this.statusFilter.valueChanges.subscribe((value) => {
      this.filteredValues.is_published = value !== '' ? value : null;
      this.paginator.pageIndex = 0;
      if (!this.isReset) {
        this.getData();
      }
    });
  }
  getSchools() {
    this.isWaitingForResponse = true;
    this.subs.sink = this.rncpTitleService.getAllSchool('preparation_center', this.classId).subscribe((resp) => {
      if (resp) {
        this.schoolDropdown = cloneDeep(resp);
      }
      this.isWaitingForResponse = false;
    });
  }
  getUserType() {
    this.isLoading = true;
    this.subs.sink = this.user.getAllUserTypeExcludeComp().subscribe(
      (resp) => {
        if (resp) {

          this.userType = cloneDeep(resp).map((type) => (type.name === 'ADMTC Director' ? { ...type, name: 'Title Manager' } : type));
        }
        this.isLoading = false;
      },
      (err) => {
        this.isLoading = false;

      },
    );
  }
  reset() {
    this.selection.clear();
    this.taskRefFilter.setValue('', { emitEvent: false });
    this.scopeTaskFilter.setValue('', { emitEvent: false });
    this.taskTitleFilter.setValue('', { emitEvent: false });
    this.assignToFilter.setValue('', { emitEvent: false });
    this.assignerFilter.setValue('', { emitEvent: false });
    this.dueDateFilter.setValue('', { emitEvent: false });
    this.statusFilter.setValue('', { emitEvent: false });
    this.paginator.pageIndex = 0;
    this.sortValue = null;
    this.sort.direction = '';
    this.sort.active = '';
    this.sort.sort({ id: '', start: 'asc', disableClear: false });
    this.filteredValues = {
      ref_id: null,
      task_scope: null,
      task_title: null,
      assigner_id: null,
      assign_to_id: null,
      due_date: null,
      is_published: null,
    };
    this.isReset = true;
    this.getData();
  }
  addNewTask() {
    if (this.rncpTitleId) {
      this.router.navigate(['/title-rncp/task-builder/', this.rncpTitleId], {
        queryParams: { type: 'create', titleId: this.rncpTitleId, classId: this.classId },
      });
    }
  }
  editTask(id) {
    if (id) {
      this.router.navigate(['/title-rncp/task-builder/', this.rncpTitleId], {
        queryParams: { type: 'edit', taskId: id, titleId: this.rncpTitleId, classId: this.classId },
      });
    }
  }
  viewTask(id) {
    if (id) {
      this.router.navigate(['/title-rncp/task-builder/', this.rncpTitleId], {
        queryParams: { type: 'view', taskId: id, titleId: this.rncpTitleId, classId: this.classId },
      });
    }
  }
  async deleteTask(id, title) {
    if (id && title) {
      const inputText = {
        task: title,
      };
      const confirmation = await this.fireCountdownSwal('DELETE_TASK_S1', inputText);
      if (confirmation.value) {
        this.isWaitingForResponse = true;
        this.subs.sink = this.rncpTitleService.removeTaskBuilder(id).subscribe(
          async (resp) => {
            this.isWaitingForResponse = false;
            if (resp) {
              await this.fireSwalBravo();
              this.getData();
            }
          },
          (error) => {
            this.isWaitingForResponse = false;
            if (error['message'] === 'GraphQL error: This task builder have next task') {
              Swal.fire({
                type: 'warning',
                title: this.translate.instant('DELETE_TASK_S3.TITLE'),
                html: this.translate.instant('DELETE_TASK_S3.TEXT'),
                footer: `<span style="margin-left: auto">DELETE_TASK_S3</span>`,
                confirmButtonText: this.translate.instant('DELETE_TASK_S3.BUTTON_1'),
              });
            }

          },
        );
      }
    }
  }

  async unpublishTask(task) {
    const inputText = { taskName: task.task_title };
    const confirmation = await this.fireCountdownSwal('UNGENERATE_S2', inputText);
    if (confirmation.value) {
      this.isWaitingForResponse = true;
      this.subs.sink = this.taskService.unpublishTaskBuilder(task._id).subscribe(
        async (resp) => {
          if (resp) {
            this.isWaitingForResponse = false;
            await this.fireSwalBravo();
            this.getData();
          }
        },
        (error) => {
          this.isWaitingForResponse = false;
          if (error && error.message) {
            const errorObject = JSON.parse(error.message.split(' ').slice(2).join(' '));

            if (errorObject && errorObject.message && errorObject.message === 'Can not unpublished task builder that have next task') {
              Swal.fire({
                type: 'warning',
                title: this.translate.instant('UNGENERATE_S3.TITLE'),
                html: this.translate.instant('UNGENERATE_S3.TEXT', {
                  nextTaskRef: errorObject.next_task_ref_id,
                  nextTaskTitle: errorObject.next_task_task_title,
                }),
                footer: `<span style="margin-left: auto">UNGENERATE_S3</span>`,
                confirmButtonText: this.translate.instant('UNGENERATE_S3.BUTTON_1'),
              }).then((res) => {
                if (res.value) this.getData();
              });
            }
          }
        },
      );
    }
  }

  async publishOrGenerateTask(task) {
    const inputText = { taskname: task && task.task_title ? task.task_title : '' };
    const confirmation = await this.fireCountdownSwal('GENERATE_S1B', inputText);
    if (confirmation.value) {
      this.isWaitingForResponse = true;
      const mutation = this.generateTask(task._id);
      this.subs.sink = mutation.subscribe(
        async (resp) => {
          if (resp) await this.fireSwalBravo();
          this.isWaitingForResponse = false;
          this.onGenerateAllTask.emit(true);
        },
        async (err) => {
          this.isWaitingForResponse = false;
          const errorMessage = err.message.includes('cannot generate task as previous task not generated');
          if (err && err.message && err.message === 'GraphQL error: task builder have no assigner or assgine to yet') {
            await this.fireSwalWarning('PUBLISHTASK_S1C');
            return;
          }
          if (err && err.message && err.message === 'GraphQL error: the class have no preparation center yet') {
            await this.fireSwalWarning('PUBLISHTASK_S1D');
            return;
          }
          if (err.message && errorMessage) {
            await this.errorGenerateTask(err.message);
            return;
          }
        },
      );
    }
  }

  publishTask(_id: string) {
    return this.rncpTitleService.publishTaskBuilder(_id);
  }

  generateTask(_id: string) {
    return this.taskService.generateTaskBuilders(this.rncpId, this.classId, [_id]);
  }

  transformDate(date) {
    if (date && date.date && date.time) {
      const localDate = this.parseUTCtoLocal.transformDate(date.date, date.time);
      // const datee = localDate !== 'Invalid date' ? moment(date, 'DD/MM/YYYY').format('DD/MM/YYYY') : '';
      return localDate;
    } else {
      return '';
    }
  }

  async generateAllTask() {
    this.getSelectedData();
    const confirmation = await this.fireCountdownSwal('GENERATE_S1', {});
    if (confirmation.value) {
      this.isWaitingForResponse = true;

      this.taskService.generateAllTaskBuilders(this.rncpId, this.classId, this.taskIds).subscribe(
        async (resp) => {
          if (resp) {
            await this.fireSwalBravo();
            this.isAllChecked = false;
            this.selection.clear();
            this.onGenerateAllTask.emit(true);
          }
        },
        async (err) => {
          this.isWaitingForResponse = false;
          if (err && err.message) {
            const errorMessage = err.message.includes('cannot generate task as previous task not generated');
            if (err.message === 'GraphQL error: task builder have no assigner or assgine to yet') {
              await this.fireSwalWarning('PUBLISHTASK_S1C');
              return;
            }
            if (err.message && err.message === 'GraphQL error: the class have no preparation center yet') {
              await this.fireSwalWarning('PUBLISHTASK_S1D');
              return;
            }
            if (err.message && errorMessage) {
              this.errorGenerateTask(err.message);
            }
          }
        },
      );
    }
  }

  async fireCountdownSwal(localizationRef: string, textInput: any) {
    let timeout = 2;
    let confirmInterval;
    return await Swal.fire({
      type: 'warning',
      title: this.translate.instant(`${localizationRef}.TITLE`),
      html: this.translate.instant(`${localizationRef}.TEXT`, textInput),
      footer: `<span style="margin-left: auto">${localizationRef}</span>`,
      confirmButtonText: this.translate.instant(`${localizationRef}.BUTTON_1`) + ` (${timeout})`,
      cancelButtonText: this.translate.instant(`${localizationRef}.BUTTON_2`),
      showCancelButton: true,
      onOpen: () => {
        timeout--;
        Swal.disableConfirmButton();
        const confirmButtonRef = Swal.getConfirmButton();
        confirmInterval = setInterval(() => {
          if (timeout > 0) {
            (confirmButtonRef.innerText = this.translate.instant(`${localizationRef}.BUTTON_1`) + ` (${timeout})`), timeout--;
          } else {
            Swal.enableConfirmButton();
            confirmButtonRef.innerText = this.translate.instant(`${localizationRef}.BUTTON_1`);
            clearInterval(confirmInterval);
          }
        }, 1000);
      },
    });
  }

  async fireSwalWarning(localizationRef: string, inputText?) {

    return await Swal.fire({
      type: 'warning',
      title: this.translate.instant(`${localizationRef}.TITLE`),
      html: this.translate.instant(`${localizationRef}.TEXT`, inputText),
      footer: `<span style="margin-left: auto">${localizationRef}</span>`,
      confirmButtonText: this.translate.instant(`${localizationRef}.BUTTON_1`),
      allowOutsideClick: false,
      allowEscapeKey: false,
    });
  }

  async fireSwalBravo() {
    return await Swal.fire({
      type: 'success',
      title: this.translate.instant('Bravo'),
      confirmButtonText: this.translate.instant('OK'),
      allowOutsideClick: false,
      allowEscapeKey: false,
    });
  }

  async errorGenerateTask(data) {
    const regex = /\{([^()]*)\}/g;
    const dataMessage = data.match(regex);
    const splitData = dataMessage[0].split('; ');

    let taskListHTML = '';
    splitData.forEach((data) => {
      data = data.replace('{', '').replace('}', '').split(', ');
      const [taskRef, title] = data;
      taskListHTML += `<p>- ${taskRef} - ${title}</p>`;


    });

    return await Swal.fire({
      type: 'warning',
      title: this.translate.instant('GENERATE_S1D.TITLE'),
      html: this.translate.instant('GENERATE_S1D.HTML', { taskListHTML }),
      footer: `<span style="margin-left: auto">GENERATE_S1D</span>`,
      confirmButtonText: this.translate.instant('GENERATE_S1D.BUTTON_1'),
      allowOutsideClick: false,
      allowEscapeKey: false,
    });
  }

  getSelectedData() {
    if (this.isAllChecked) {
      this.getData();

    } else {
      this.taskIds = [...this.dataSource.data].filter((data) => this.selection.selected.includes(data._id)).map((el) => el._id);
    }
  }

  onMasterToggle($event) {
    if (this.isAllChecked) this.selection.clear();
    if (!this.isAllChecked) this.dataSource.data.forEach((row) => row && row._id && this.selection.select(row._id));
    this.isAllChecked = $event.checked;

  }

  onIndividualToggle($event, row) {
    if (row && row._id) this.selection.toggle(row._id);
    const isAllSelected = this.selection.selected.length === this.dataSource.data.length;
    if ($event.checked === false) this.isAllChecked = false;
    if ($event.checked && isAllSelected) this.isAllChecked = true;
  }

  ngOnDestroy(): void {
    this.subs.unsubscribe();
  }
}
